REG: Register, denoted with $
PLT: Pointer to memory, enclosed with [ ]
LIT: Literal value, no sigil
LAB: Label, is text

hlt  none
mov  [REG] [LIT|PTR|REG]
jmp  [LIT|PTR|LAB]
jmpf [LIT]
jmpb [LIT]
cmp  [REG|LIT] [REG|LIT]
lt   [REG|LIT] [REG|LIT]
gt   ""
le   ""
ge   ""
jeq  [LIT|PTR|LAB]
jne  ""
aloc [LIT|PTR|REG]
dalc [LIT|PTR|REG]
add  [REG|LIT|PTR] [REG|LIT|PTR] [REG]
sub  ""
mul  ""
div  ""
igl  none

How registers, pointers and literals are denoted in memory
1. VM reads opcode
2. VM gets next byte from program
    If there is only one possible operand, the VM skips this step
3. byte value:
    0 -> literal (i32)
    1 -> pointer (usize) (labels get replaced with pointers at assembly)
    2 -> register (u8)
    _ -> (throws error)
4. VM parses next few bytes as necessary

Directives: Instructions to the assembler
Begin with '.'

.str -> Reserves a string
