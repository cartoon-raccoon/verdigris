REG: Register, denoted with $
PLT: Pointer to memory, enclosed with [ ]
LIT: Literal value, no sigil
LAB: Label, is text

hlt  none
mov  [PTR|REG] [LIT|PTR|REG]
jmp  [LIT|PTR|LAB]
jmpf [REG|LIT]
jmpb [REG|LIT]
cmp  [REG|LIT] [REG|LIT]
lt   [REG|LIT] [REG|LIT]
gt   ""
le   ""
ge   ""
jeq  [LIT|PTR|LAB]
jne  ""
aloc [LIT|PTR|REG]
dalc [LIT|PTR|REG]
push ???
pop  ???
call [LAB] ???
ret  ??? (calling conventions not yet specified)
prt  [LAB|PTR] (continuously writes bytes to stdout until \0)
open ??? (file i/o conventions not yet worked out)
clse ??? 
read [REG|LIT] (bytes)
wrt  [PTR] [LIT|REG]
inc  [REG|LIT] [REG]
dec  ""
add  [REG|LIT] [REG|LIT] [REG]
sub  ""
mul  ""
div  ""
and  ""
not  ""
or   ""
xor  ""
bsl  ""
bsr  ""
igl  none

How registers, pointers and literals are denoted in memory
1. VM reads opcode
2. VM gets next byte from program
    If there is only one possible operand, the VM skips this step
3. byte value:
    0 -> literal (i32)
    1 -> pointer (usize) (labels get replaced with pointers at assembly)
    2 -> register (u8)
    _ -> (throws error)
4. VM parses next few bytes as necessary

Directives: Instructions to the assembler
Begin with '.'

.str -> Reserves a string
